"""
Runs our optimized method and the normal method;
Dumps a dictionary that can be used as a row for a pandas dataframe
"""

from collections import defaultdict
import networkx as nx
import numpy as np
import argparse
from pathlib import Path
import timeit
import pickle
import copy
import signal
from qtensor import QAOA_energy, QAOAQtreeSimulator, DefaultQAOAComposer

# loosely based on https://stackoverflow.com/questions/492519/timeout-on-a-function-call

def timeout_handler(signum, frame):
    print("Time out triggered, cleaning up")
    raise TimeoutError()


def import_dimacs(fname):
    nnodes = None
    nedges = None
    elist = []
    with open(fname, 'r') as f:
        for line in f:
            if line[0] == 'c':
                # comment, skip
                continue
            line = line.rstrip().split()
            if line[0][0] == 'p':
                # problem line
                assert(line[1] == 'edge')
                nnodes = int(line[2])
                nedges = int(line[3])
            elif line[0][0] == 'e':
                # edge line
                elist.append((int(line[1]), int(line[2])))
    assert(nnodes is not None and nedges is not None)
    assert(len(elist) == nedges)
    G = nx.Graph()
    G.add_edges_from(elist)
    return nx.convert_node_labels_to_integers(G)


def main(res, G):
    """
    Runs and populates res
    """

    gamma, beta = [np.pi/3] * args.p, [np.pi/2] * args.p
    
    res['gamma'] = gamma
    res['beta'] = beta
    res['accelerated_nedges_processed'] = 0

    res['accelerated_start_time'] = timeit.default_timer()

    sim = QAOAQtreeSimulator(DefaultQAOAComposer, max_tw=30)
    
    total_E = 0
    for orb_idx, orb_edges in res['eorbits'].items():
        E = sim._get_edge_energy(G, gamma, beta, orb_edges[0])
        res['accelerated_nedges_processed'] += 1
        if np.imag(E)>1e-6:
            print(f"Warning: Energy result imaginary part was: {np.imag(E)}")
        E = np.real(E)
        total_E += len(orb_edges) * E
    
    E1 = (G.number_of_edges() - total_E) / 2
    
    res['accelerated_done_computing_energy_time'] = timeit.default_timer()
    res['time_accelerated'] = res['accelerated_done_computing_energy_time'] - res['accelerated_start_time']
    
    print(f"Accelerated method finished in {res['time_accelerated']:.2f} s, E = {E1}")

    return E1


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--graph", type = Path,
        required = True,
        help = "path to input graph")
    parser.add_argument(
        "--outpath", type = Path,
        required = True,
        help = "path to the folder to dump result")
    parser.add_argument(
        "-p", type = int,
        required = True,
        help = "path to dump the result")
    parser.add_argument(
        "--timeout", type = int,
        default = 0,
        help = "timeout (longest running time allowed), seconds")
    args = parser.parse_args()

    G = import_dimacs(args.graph)
    
    print(nx.info(G))

    outpath = (args.outpath.joinpath(f"{args.graph.stem}_{args.p}")).with_suffix('.p')

    orbits_path = f'./data/0301_compute_orbs/{args.graph.stem}_dreadnaut.p'

    print("Outpath: ", outpath, 'orbits path: ', orbits_path)

    res = {'G': copy.deepcopy(G), '|E|': G.number_of_edges(), '|V|': G.number_of_nodes()}

    orbit_info = pickle.load(open(orbits_path, 'rb'))
    res['eorbits'] = orbit_info['eorbits']

    signal.signal(signal.SIGALRM, timeout_handler) 
    signal.alarm(args.timeout)

    try:
        E = main(res, G)
        res['completed'] = True
        res['Energy'] = E
    except TimeoutError:
        res['termination_time'] = timeit.default_timer()
        res['completed'] = False
        if 'accelerated_start_time' in res.keys():
            print(f"Estimated serial runtime: {(len(res['eorbits']) / res['accelerated_nedges_processed']) * (res['termination_time'] - res['accelerated_start_time'])}")
    finally:
        signal.alarm(0)

    pickle.dump(res, open(outpath, 'wb'))
