"""
Runs our optimized method and the normal method;
Dumps a dictionary that can be used as a row for a pandas dataframe
"""

from collections import defaultdict
import networkx as nx
import numpy as np
import argparse
from pathlib import Path
import timeit
import pickle
import copy
import signal
import random
from qtensor import QAOA_energy, QAOAQtreeSimulator, DefaultQAOAComposer

# loosely based on https://stackoverflow.com/questions/492519/timeout-on-a-function-call

def timeout_handler(signum, frame):
    print("Time out triggered, cleaning up")
    raise TimeoutError()


def visit_edges_randomly(G):
    edges = list(G.edges())
    random.shuffle(edges)
    return edges


def import_dimacs(fname):
    nnodes = None
    nedges = None
    elist = []
    with open(fname, 'r') as f:
        for line in f:
            if line[0] == 'c':
                # comment, skip
                continue
            line = line.rstrip().split()
            if line[0][0] == 'p':
                # problem line
                assert(line[1] == 'edge')
                nnodes = int(line[2])
                nedges = int(line[3])
            elif line[0][0] == 'e':
                # edge line
                elist.append((int(line[1]), int(line[2])))
    assert(nnodes is not None and nedges is not None)
    assert(len(elist) == nedges)
    G = nx.Graph()
    G.add_edges_from(elist)
    return nx.convert_node_labels_to_integers(G)


def main(res, G):
    """
    Runs and populates res
    """

    gamma, beta = [np.pi/3] * args.p, [np.pi/2] * args.p
    
    res['gamma'] = gamma
    res['beta'] = beta
    res['serial_nedges_processed'] = 0
    
    res['serial_start_time'] = timeit.default_timer()
    sim = QAOAQtreeSimulator(DefaultQAOAComposer, max_tw=30)
    
    total_E = 0
    for edge in visit_edges_randomly(G):
        E = sim._get_edge_energy(G, gamma, beta, edge)
        res['serial_nedges_processed'] += 1
        if np.imag(E)>1e-6:
            print(f"Warning: Energy result imaginary part was: {np.imag(E)}")
        total_E += E
    
    E2 = sim._post_process_energy(G, total_E)

    res['serial_end_time'] = timeit.default_timer()
    res['time_serial'] = res['serial_end_time'] - res['serial_start_time']
    
    print(f"Default method finished in {res['time_serial']:.2f} s")


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--graph", type = Path,
        required = True,
        help = "path to input graph")
    parser.add_argument(
        "--outpath", type = Path,
        required = True,
        help = "path to the folder to dump result")
    parser.add_argument(
        "-p", type = int,
        required = True,
        help = "path to dump the result")
    parser.add_argument(
        "--timeout", type = int,
        default = 0,
        help = "timeout (longest running time allowed), seconds")
    parser.add_argument(
        "--seed", type = int,
        default = 42,
        help = "random seed")
    args = parser.parse_args()

    random.seed(args.seed)

    G = import_dimacs(args.graph)
    
    print(nx.info(G))

    outpath = (args.outpath.joinpath(f"{args.graph.stem}_{args.p}")).with_suffix('.p')

    print("Outpath: ", outpath)

    res = {'G': copy.deepcopy(G), '|E|': G.number_of_edges(), '|V|': G.number_of_nodes()}

    signal.signal(signal.SIGALRM, timeout_handler) 
    signal.alarm(args.timeout)

    try:
        main(res, G)
        res['completed'] = True
    except TimeoutError:
        res['termination_time'] = timeit.default_timer()
        res['completed'] = False
        if 'serial_start_time' in res.keys():
            print(f"Estimated serial runtime: {(res['|E|'] / res['serial_nedges_processed']) * (res['termination_time'] - res['serial_start_time'])}")
    finally:
        signal.alarm(0)

    pickle.dump(res, open(outpath, 'wb'))
