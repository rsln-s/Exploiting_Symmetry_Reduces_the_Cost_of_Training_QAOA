# -*- coding: utf-8 -*-
"""
Wrapper around dreadnaut that computes the orbits of a graph.

NOTE: Must have installed `dreandaut`. The location of the binary can be passed
      as an argument to `compute_automorphisms`.

Author: Jean-Gabriel Young <info@jgyoung.ca>
From https://gist.github.com/jg-you/ff9ba9bfac1f24ecc2a8f31cc89c5067
"""
import subprocess
import networkx as nx
from os import remove
import timeit
import argparse
from pathlib import Path
from collections import defaultdict
import pickle
import uuid
import os


def check_if_edge_belongs_to_existing_orbit(e1, eorbits, vorbits):
    # returns orbit index if yes, None otherwise
    for orb_idx, orb_edges in eorbits.items():
        for e2 in orb_edges:
            # check that either e1[0], e2[0] and e1[1], e2[1] are on the same obit
            # or e1[0], e2[1] and e1[1], e2[0] are on the same orbit 
            if (((vorbits[e1[0]] == vorbits[e2[0]]) and (vorbits[e1[1]] == vorbits[e2[1]])) or 
                    ((vorbits[e1[0]] == vorbits[e2[1]]) and (vorbits[e1[1]] == vorbits[e2[0]]))):
                return orb_idx
    return None


def import_dimacs(fname):
    nnodes = None
    nedges = None
    elist = []
    with open(fname, 'r') as f:
        for line in f:
            if line[0] == 'c':
                # comment, skip
                continue
            line = line.rstrip().split()
            if line[0][0] == 'p':
                # problem line
                assert(line[1] == 'edge')
                nnodes = int(line[2])
                nedges = int(line[3])
            elif line[0][0] == 'e':
                # edge line
                elist.append((int(line[1]), int(line[2])))
    assert(nnodes is not None and nedges is not None)
    assert(len(elist) == nedges)
    G = nx.Graph()
    G.add_edges_from(elist)
    return nx.convert_node_labels_to_integers(G)


def _build_dreadnaut_file(g):
    """Prepare file to pass to dreadnaut.

    Warning
    -------
    Assumes that the nodes are represented by the 0 indexed integers.
    """
    # dreadnaut options
    file_content = ["As"]  # sparse mode
    file_content.append("-a")  # do not print out automorphisms
    file_content.append("-m")  # do not print out level markers
    # specify graph structure
    file_content.append("n=" + str(g.number_of_nodes()) + " g")
    for v in g.nodes():
          line = " " + str(v) + " : "
          for nb in g.neighbors(v):
              if v < nb:
                  line += str(nb) + " "
          line += ";"
          file_content.append(line)
    # add nauty command
    file_content.append(".")
    file_content.append("x")
    file_content.append("o")
    return file_content


def compute_automorphisms(g):
    if "DREADNAUT_PATH" not in os.environ:
        raise EnvironmentError("To use this script you must set `$DREADNAUT_PATH` to be the path to dreadnaut installation, e.g. `export DREADNAUT_PATH=~/soft/nauty27r1/dreadnaut`")
    dreadnaut_call = os.environ["DREADNAUT_PATH"]
    # get dreadnaut command file
    file_content = _build_dreadnaut_file(g)
    # write to tmp_path
    tmp_path="/tmp/" + str(uuid.uuid4().hex)
    with open(tmp_path, 'w') as f:
        print("\n".join(file_content), file=f)
    # call dreadnaut
    proc = subprocess.run([dreadnaut_call],
                          input=b"< " + tmp_path.encode(),
                          stdout=subprocess.PIPE,
                          stderr=subprocess.DEVNULL)
    [info, _, orbits] = proc.stdout.decode().strip().split("\n", 2)
    # ~~~~~~~~~~~~~~
    # Extract high level info from captured output
    # ~~~~~~~~~~~~~~
    num_orbits = int(info.split(" ")[0])
    num_gen = int(info.split(" ")[3])
    # ~~~~~~~~~~~~~~
    # Extract orbits
    # ~~~~~~~~~~~~~~
    # This big list comprehension splits all orbits into their own sublist, and
    # each of these orbits into individual components (as string).
    # There is still some post-processing to do since some of them are in the
    # compact notation X:X+n when the n+1 nodes of the orbits are contiguous.
    X = [_.strip().split(" (")[0].split(" ")
         for _ in orbits.replace("\n   ",'').strip().split(";")[:-1]]
    for i, orbit in enumerate(X):
        final_orbit = []
        for elem in orbit:
            if ":" in elem:
                _ = elem.split(":")
                final_orbit += range(int(_[0]), int(_[1]) + 1)
            else:
                final_orbit += [int(elem)]
        X[i] = final_orbit
    # garbage collection
    remove(tmp_path)
    return num_orbits, num_gen, X

if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--graph", type = Path,
        required = True,
        help = "path to input graph")
    parser.add_argument(
        "--outpath", type = Path,
        required = True,
        help = "path to the folder to dump result")
    args = parser.parse_args()

    # declare networkx graph
    G = import_dimacs(args.graph)
    print(nx.info(G))
    outpath = (args.outpath.joinpath(f"{args.graph.stem}")).with_suffix('.p')
    print("Outpath: ", outpath)

    start_time = timeit.default_timer()
    # orbits and generators of the graph
    num_orbits, num_gen, X = compute_automorphisms(G)
    vorbits = [None for i in range(G.number_of_nodes())]
    for idx, orbit in enumerate(X):
        for v in orbit:
            vorbits[v] = idx

    eorbits = defaultdict(list)
    
    for e in G.edges():
        orb_idx = check_if_edge_belongs_to_existing_orbit(e, eorbits, vorbits)
        if orb_idx is not None:
            eorbits[orb_idx].append(e)
        else:
            eorbits[len(eorbits)].append(e)
    
    runtime = timeit.default_timer() - start_time
    print(f'Finished computing in {runtime:.2f}')
    print("Graph:\t\t", "num_orbits=" +str(num_orbits))
    print(f"Found {len(eorbits)} edge orbits")
     
    res = {'G': G, '|E|': G.number_of_edges(), '|V|': G.number_of_nodes(), 'num vorbits':num_orbits, 'method output' : X, 'runtime':runtime, 'eorbits':eorbits, 'vorbits':vorbits}
    pickle.dump(res, open(outpath, 'wb'))
